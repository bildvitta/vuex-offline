{"version":3,"file":"index.min.js","sources":["../src/databaseSetup.js","../src/utils/collectionHandler.js","../src/utils/parseHandler.js","../src/utils/filtersHandler.js","../src/utils/formatError.js","../src/utils/relationsHandler.js","../src/utils/uuid.js","../src/utils/validateCustomError.js","../src/utils/nested.js","../src/vuexOffline.js","../src/utils/seeder.js"],"sourcesContent":["import { createRxDatabase, addRxPlugin } from 'rxdb'\n\n/**\n * Class to abstract the PouchDB implementation.\n *\n  * @param {options} DatabaseSetup options.\n */\nexport default class {\n  constructor (options = { databaseOptions: {} }) {\n    this.options = options\n    this.databaseOptions = options.databaseOptions\n    this.databaseName = this.databaseOptions.alias || this.databaseOptions.name\n    this.collectionsOptions = options.collections\n\n    this.database = null\n    this.collections = null\n\n    this.initialize()\n  }\n\n  initialize () {\n    this.addPlugins([\n      require('pouchdb-adapter-idb'),\n      require('pouchdb-adapter-http')\n    ])\n  }\n\n  /**\n   * Add a plugin to rxdb.\n   *\n   * @param {addRxPlugin} plugin PouchDB plugin\n   */\n  addPlugin (plugin) {\n    addRxPlugin(plugin)\n  }\n\n  /**\n   * Add a list of plugins to PouchDB.\n   *\n   * @param {PouchDB[]} plugins List of PouchDB plugins\n   */\n  addPlugins (plugins) {\n    return plugins.forEach(plugin => this.addPlugin(plugin))\n  }\n\n  async createDatabase () {\n    try {\n      this.database = await createRxDatabase(this.databaseOptions)\n\n      return this.database\n    } catch (error) {\n      throw new Error('Error creating database.', error)\n    }\n  }\n\n  /**\n   * Get the database\n   *\n   * @param {string} name name of db.\n   *\n   * @example\n   * databaseSetup.getDatabase('myDatabase')\n   */\n  getDatabase (name) {\n    return this.databases[name]\n  }\n\n  /**\n   * Get the databases list\n   */\n  getDatabaseList () {\n    return this.databases\n  }\n\n  /**\n   * Delete the database. Note that this has no impact on other replicated databases.\n   * Check: {@link https://rxdb.info/rx-database.html#destroy}\n   *\n   * @param {string} name name of database to be deleted\n   *\n   * @example\n   * databaseSetup.deleteDatabase('myDatabase')\n   */\n  async deleteDatabase (name) {\n    const database = this.getDatabase(name)\n\n    if (!database) {\n      throw new Error('Please provide a valid database to be deleted.')\n    }\n\n    try {\n      await database.destroy()\n    } catch (error) {\n      throw new Error('Error deleting database.', error)\n    }\n  }\n\n  async createCollections (collections) {\n    try {\n      // addCollections from rxdb\n      const collection = await this.database.addCollections(collections || this.collectionsOptions)\n      this.collections = this.database.collections\n\n      return collection\n    } catch (error) {\n      throw new Error('Error creating collections.', error)\n    }\n  }\n}\n","export default class {\n  constructor (collection) {\n    this.collection = collection\n  }\n\n  async getCount (query) {\n    const list = await this.collection.find(query).exec()\n\n    return list.length\n  }\n\n  getCustomFields (callback = function () {}) {\n    const customFields = {}\n    const fields = this.getAllFields()\n\n    for (const key in fields) {\n      if (fields[key].props) {\n        customFields[key] = fields[key].props\n        callback(fields[key].props)\n      }\n    }\n\n    return customFields\n  }\n\n  getAllFields () {\n    return this.collection.schema.jsonSchema.properties\n  }\n\n  getFiltersFields () {\n    const filtersFields = {}\n    const customFields = this.getCustomFields()\n\n    for (const key in customFields) {\n      const filters = customFields[key].filter\n\n      if (!filters) continue\n\n      if (typeof filters === 'boolean') {\n        filtersFields[key] = customFields[key].field\n        continue\n      }\n\n      for (const filtersKey in filters) {\n        filtersFields[filtersKey] = filters[filtersKey]\n      }\n    }\n\n    return filtersFields\n  }\n\n  getOnlyFields () {\n    const customFields = this.getCustomFields()\n    const fields = {}\n\n    for (const key in customFields) {\n      if (customFields[key].field) {\n        fields[key] = customFields[key].field\n      }\n    }\n\n    return fields\n  }\n\n  getFiltersAndSearch () {\n    const customFields = this.getFiltersFields()\n    const object = {\n      filters: [],\n      search: []\n    }\n\n    for (const key in customFields) {\n      object.filters.push(key)\n      customFields[key].search && object.search.push(key)\n    }\n\n    return object\n  }\n\n  getNestedFields (callback = function () {}) {\n    const nestedFields = {}\n\n    this.getCustomFields(custom => {\n      const { field } = custom\n\n      if (field && field.type === 'nested') {\n        nestedFields[field.name] = custom\n        callback(custom)\n      }\n    })\n\n    return nestedFields\n  }\n\n  getFieldsWithRelation () {\n    const fields = {}\n    const allFields = this.getAllFields()\n\n    for (const key in allFields) {\n      if (allFields[key].ref) {\n        fields[key] = allFields[key]\n      }\n    }\n\n    return fields\n  }\n}\n","export default class {\n  parseValue (value) {\n    try { return JSON.parse(value) } catch { return value }\n  }\n\n  parseBoolean (value) {\n    return ['true', 'false'].some(item => item === value) ? this.parseValue(value) : value\n  }\n}\n","import ParseHandler from './parseHandler'\n\nexport default class {\n  constructor({ receivedFilters, filtersList, receivedSearch = '', searchList, fieldsList }) {\n    this.fieldsList = fieldsList\n    this.filtersList = filtersList\n    this.receivedFilters = receivedFilters\n    this.receivedSearch = receivedSearch\n    this.searchList = searchList\n    this.parseHandler = new ParseHandler()\n  }\n\n  getFilterFields () {\n    const filters = {}\n\n    for (const filter of this.filtersList) {\n      if (!this.fieldsList[filter]) {\n        throw new Error(`Filter \"${filter}\" doesn't exists.`)\n      }\n\n      filters[filter] = this.fieldsList[filter]\n    }\n\n    return filters\n  }\n\n  _setDefaultValueToQueryOperator (queryOperator, value) {\n    const defaultValues = {\n      $all: [value],\n      $eq: this.parseHandler.parseBoolean(value)\n    }\n\n    if (!(queryOperator in defaultValues)) {\n      return value\n    }\n\n    return defaultValues[queryOperator]\n  }\n\n  transformQuery () {\n    const transformedQuery = {}\n\n    for (const item of this.filtersList) {\n      const filterField = this.fieldsList[item]\n      transformedQuery[filterField.queryOrigin || item] = transformedQuery[filterField.queryOrigin || item] || {}\n\n      if (this.receivedFilters[item]) {\n        Object.assign(\n          transformedQuery[filterField.queryOrigin || item],\n          filterField.queryOperator\n            ? {\n              [filterField.queryOperator]: this._setDefaultValueToQueryOperator(\n                filterField.queryOperator, this.receivedFilters[item]\n              )\n            }\n            : { $regex: `.*${this.receivedFilters[item]}.*` }\n          )\n\n        continue\n      }\n\n      if (this.receivedSearch && filterField.search) {\n        Object.assign(transformedQuery[filterField.queryOrigin || item], { $regex: `.*${this.receivedSearch}.` })\n      }\n    }\n\n    return {\n      selector: {\n        ...transformedQuery\n      }\n    }\n  }\n}\n","export default class {\n  constructor ({ errors, status = { code: 400 } } = {}) {\n    return {\n      response: {\n        data: {\n          errors,\n          status\n        }\n      }\n    }\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport { cloneDeep } from 'lodash'\n\nexport default class {\n  constructor (collection, collections) {\n    this.collectionHandler = new CollectionHandler(collection)\n    this.fieldsWithRelation = this.collectionHandler.getFieldsWithRelation()\n    this.collections = collections\n  }\n\n  setOptions (documents = [], key) {\n    documents = Array.isArray(documents) ? documents : [documents]\n\n    const options = []\n\n    documents.forEach(document => {\n      const parsedDocument = document.toJSON()\n      const fieldProps = this.fieldsWithRelation[key].props\n\n      options.push({\n        value: fieldProps['refValue'] || document.uuid,\n        label: document[fieldProps['refLabel']],\n        data: parsedDocument\n      })\n\n      return parsedDocument\n    })\n\n    return options\n  }\n\n  async getFieldsWithRelationOptionsById (document) {\n    const fields = cloneDeep(this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      fields[key].options = this.setOptions(\n        await document.populate(key) || [], key\n      )\n    }\n\n    return fields\n  }\n\n  async getFieldsWithRelationOptions (externalFields) {\n    const fields = cloneDeep(externalFields || this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      fields[key].options = this.setOptions(\n        await this.collections[this.fieldsWithRelation[key].ref].find().exec(), key\n      )\n    }\n\n    return fields\n  }\n}\n","export default class {\n  create (date) {\n    date = date || new Date()\n\n    const uuid = this.uuidv4()\n    let comb = ('00000000000' + date.getTime().toString(16)).substr(-12)\n    comb = comb.slice(0, 8) + '-' + comb.slice(8, 12)\n\n    return uuid.replace(uuid.slice(0, 13), comb)\n  }\n\n  uuidv4 () {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n  }\n}\n","import FormatError from './formatError'\nimport CollectionHandler from './collectionHandler'\n\nexport default class {\n  constructor(rxError, collection) {\n    this.errors = rxError.parameters.errors\n    this.schema = rxError.parameters.schema\n    this.collectionHandler = new CollectionHandler(collection)\n    this.customFields = this.collectionHandler.getCustomFields()\n\n    return new FormatError({\n      errors: this.setErrors()\n    })\n  }\n\n  getErrorMessagesFromCustomFields () {\n    const errorMessages = {}\n\n    for (const key in this.customFields) {\n      if (this.customFields[key].errorMessage) {\n        errorMessages[key] = this.customFields[key].errorMessage\n      }\n    }\n\n    return errorMessages\n  }\n\n  setErrors () {\n    const errors = {}\n    const customErrors = this.getErrorMessagesFromCustomFields()\n\n    for (const error of this.errors) {\n      const { field } = error\n      const key = field.split('.')[1]\n\n      errors[key] = customErrors[key]\n    }\n\n    return errors\n  }\n}\n","export default class {\n  handler (nested = [], destroyKey = 'destroyed') {\n    if (!Array.isArray(nested)) {\n      throw new Error('Array needed.')\n    }\n\n    let index = 0\n    let counter = 1\n\n    function hasNext () {\n      return index < nested.length\n    }\n\n    function next () {\n      return nested[index++]\n    }\n\n    while (hasNext()) {\n      const current = next()\n\n      if (current.id && !current[destroyKey]) {\n        counter = current.id\n      }\n\n      if (current[destroyKey]) {\n        index--\n        nested.splice(index, 1)\n        continue\n      }\n\n      current.id = counter\n\n      for (const key in current) {\n        if (Array.isArray(current[key]) && current[key].length) {\n          this.handler(nested[index - 1][key])\n        }\n      }\n\n      counter++\n    }\n\n    return nested\n  }\n}\n","import { formatISO } from 'date-fns'\n\nimport DatabaseSetup from './databaseSetup'\nimport CollectionHandler from './utils/collectionHandler'\nimport FiltersHandler from './utils/filtersHandler'\nimport FormatError from './utils/formatError'\nimport RelationsHandler from './utils/relationsHandler'\nimport Uuid from './utils/uuid'\nimport ValidateCustomError from './utils/validateCustomError'\nimport Nested from './utils/nested'\n\nexport default class VuexOffline {\n  constructor (databaseSetup, options = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.idAttribute = options.idAttribute\n  }\n\n  async createStoreModule (collectionName, options = {}) {\n    if (!collectionName) {\n      throw new Error('CollectionName name must be sended.')\n    }\n\n    // middlewares\n    const {\n      // list\n      fetchListQuery,\n      fetchListSuccess,\n      fetchListError,\n\n      // filter\n      fetchFiltersSuccess,\n      fetchFiltersError,\n\n      // single\n      fetchSingleSuccess,\n      fetchSingleFormSuccess,\n      fetchSingleError,\n\n      // save\n      saveSuccess,\n      saveError,\n\n      // create\n      createSuccess,\n      createError\n    } = options.middlewares || {}\n\n    const idAttribute = options.idAttribute || this.idAttribute || 'uuid'\n    const perPage = options.perPage || 12\n    const collection = this.databaseSetup.collections[collectionName]\n    window.cl = this.databaseSetup.collections\n\n    const collectionHandler = new CollectionHandler(collection)\n    const { filters: filtersList, search: searchList } = collectionHandler.getFiltersAndSearch()\n    const fieldsList = collectionHandler.getFiltersFields()\n    const allFields = collectionHandler.getAllFields()\n\n    const relationsHandler = new RelationsHandler(collection, this.databaseSetup.collections)\n\n    const nested = new Nested()\n\n    const save = async ({ commit }, { payload, id, model } = {}) => {\n      try {\n        const document = collection.findOne(id || payload.uuid)\n\n        if (!document || (!id && !payload.uuid)) {\n          throw new FormatError({\n            status: { code: '404', text: 'Not found' }\n          })\n        }\n\n        if (allFields.updatedAt) {\n          payload.updatedAt = formatISO(new Date())\n        }\n\n        collectionHandler.getNestedFields(nestedField => {\n          payload[nestedField.field.name] = nested.handler(\n            payload[nestedField.field.name]\n          )\n        })\n\n        const parsedDocument = await document.update({ $set: { ...payload } })\n        const response = {\n          data: {\n            result: parsedDocument,\n            status: { code: 200 }\n          }\n        }\n\n        const saveSuccessResult = (await saveSuccess && saveSuccess(response)) || {}\n\n        commit('setErrors', { model })\n        commit('replaceItem', saveSuccessResult.result || parsedDocument.toJSON())\n\n        return saveSuccess && saveSuccessResult || response\n      } catch (error) {\n        commit('setErrors', { model, hasError: true })\n        throw saveError && saveError(error) || new ValidateCustomError(error, collection)\n      }\n    }\n\n    const module = {\n      namespaced: true,\n\n      // states\n      state: {\n        filters: {},\n        list: [],\n        totalPages: 0,\n        errors: {\n          onCreate: false,\n          onFetchSingle: false,\n          onFetchList: false,\n          onReplace: false,\n          onFetchFilters: false\n        }\n      },\n\n      // getters\n      getters: {\n        list: state => state.list,\n\n        filters: state => state.filters,\n\n        totalPages: state => state.totalPages,\n\n        byId: state => id => state.list.find(item => item[idAttribute] === id)\n      },\n\n      // mutations\n      mutations: {\n        setFilters (state, payload) {\n          state.filters = payload\n        },\n\n        setList (state, payload) {\n          const { results, increment, count } = payload\n          state.list = results || []\n\n          increment ? state.list.push(...results) : state.list = results || []\n\n          state.totalPages = Math.ceil(count / perPage)\n        },\n\n        setItemList (state, payload = {}) {\n          state.list.push(payload)\n        },\n\n        setErrors (state, { model, hasError }) {\n          state[model] = !!hasError\n        },\n\n        replaceItem (state, payload) {\n          const index = state.list.findIndex(item => item[idAttribute] === payload[idAttribute])\n\n          ~index ? state.list.splice(index, 1, payload) : state.list.push(payload)\n        },\n\n        removeItem (state, id) {\n          const index = state.list.findIndex(item => item[idAttribute] === id)\n\n          ~index && state.list.splice(index, 1)\n        }\n      },\n\n      // actions\n      actions: {\n        create: async ({ commit }, { payload }) => {\n          try {\n            const uuid = new Uuid()\n            const documentToBeInserted = { uuid: uuid.create(), ...payload }\n            const dateNow = formatISO(new Date())\n\n            if (allFields.createdAt) {\n              documentToBeInserted.createdAt = dateNow\n            }\n\n            if (allFields.updatedAt) {\n              documentToBeInserted.updatedAt = dateNow\n            }\n\n            collectionHandler.getNestedFields(nestedField => {\n              documentToBeInserted[nestedField.field.name] = nested.handler(\n                documentToBeInserted[nestedField.field.name]\n              )\n            })\n\n            const document = await collection.insert(documentToBeInserted)\n            const parsedDocument = document.toJSON()\n\n            const response = {\n              data: {\n                metadata: { ...parsedDocument },\n                status: { code: 200 }\n              }\n            }\n\n            const createSuccessResult = (await createSuccess && createSuccess(response)) || {}\n\n            commit('setErrors', { model: 'onCreate' })\n            commit('setItemList', createSuccessResult.metadata || parsedDocument)\n\n            return createSuccess && createSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onCreate', hasError: true })\n            throw createError && createError(error) || new ValidateCustomError(error, collection)\n          }\n        },\n\n        replace: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onReplace' })\n        },\n\n        update: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onUpdate' })\n        },\n\n        fetchSingle: async ({ commit }, { form, id, params, url } = {}) => {\n          const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n\n          if (!id && form) {\n            const response = {\n              data: {\n                status: { code: 200 },\n                fields: fieldsWithRelationOptions\n              }\n            }\n\n            const fetchSingleFormSuccessResult = (await fetchSingleFormSuccess && fetchSingleFormSuccess(response))\n            return fetchSingleFormSuccessResult || response\n          }\n\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: '404', text: 'Not found' }\n              })\n            }\n\n            const parsedDocument = document.toJSON()\n            const fields = form\n              ? fieldsWithRelationOptions\n              : await relationsHandler.getFieldsWithRelationOptionsById(document)\n\n            const response = {\n              data: {\n                fields,\n                result: parsedDocument,\n                status: { code: 200 }\n              }\n            }\n\n            const fetchSingleSuccessResult = (await fetchSingleSuccess && fetchSingleSuccess({ ...response })) || {}\n\n            commit('replaceItem', fetchSingleSuccessResult.result || parsedDocument)\n            commit('setErrors', { model: 'onFetchSingle' })\n\n            return fetchSingleSuccess && fetchSingleSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchSingle', hasError: true })\n            throw fetchSingleError && fetchSingleError(error) || error\n          }\n        },\n\n        fetchFilters: async ({ commit }) => {\n          try {\n            const filtersHandler = new FiltersHandler({ filtersList, fieldsList })\n            const filterFields = filtersHandler.getFilterFields()\n            const formattedFilterFields = await relationsHandler.getFieldsWithRelationOptions(filterFields)\n\n            const response = {\n              fields: formattedFilterFields,\n              status: { code: 200 }\n            }\n\n            const fetchFilterSuccessResult = (await fetchFilterSuccess && fetchFilterSuccess(response)) || {}\n            commit('setFilters', fetchFilterSuccessResult.fields || formattedFilterFields)\n\n            return fetchFilterSuccess && fetchFilterSuccessResult || response\n          } catch (error) {\n            throw fetchSingleError && fetchSingleError(error) || error\n          }\n        },\n\n        fetchList: async ({ commit }, options = {}) => {\n          const { filters = {}, increment, ordering = [], page = 1, limit, search } = options\n          try {\n            const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n            const filtersHandler = new FiltersHandler({\n              receivedFilters: filters,\n              filtersList,\n              receivedSearch: search,\n              searchList,\n              fieldsList\n            })\n\n            const query = (\n              fetchListQuery && fetchListQuery({\n                fieldsWithRelationOptions, ...options\n              }) || filtersHandler.transformQuery()\n            )\n\n            const skip = (page - 1) * (limit || perPage)\n            const count = await collectionHandler.getCount(query)\n            const documents = await collection.find(query).limit(limit || perPage).skip(skip).exec()\n            const parsedDocuments = documents.map(document => document.toJSON())\n\n            const response = {\n              data: {\n                results: parsedDocuments,\n                fields: fieldsWithRelationOptions,\n                status: { code: 200 }\n              }\n            }\n\n            const fetchListSuccessResult = (await fetchListSuccess && fetchListSuccess(response)) || {}\n\n            commit('setList', { results: fetchListSuccessResult.results || parsedDocuments, increment, count })\n            commit('setErrors', { model: 'onFetchList' })\n\n            return fetchListSuccess && fetchListSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchList', hasError: true })\n            throw fetchListError && fetchListError(error) || error\n          }\n        },\n\n        destroy: async ({ commit }, { id } = {}) => {\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: 404, text: 'Not found' }\n              })\n            }\n\n            document.remove()\n\n            commit('removeItem', id)\n            commit('setErrors', { model: 'onDestroy' })\n\n            return { status: { code: 200 } }\n          } catch (error) {\n            commit('setErrors', { model: 'onDestroy', hasError: true })\n            throw error\n          }\n        }\n      }\n    }\n\n    Object.assign(module.actions, options.actions)\n    Object.assign(module.mutations, options.mutations)\n\n    return module\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport Uuid from './uuid'\nimport DatabaseSetup from '../databaseSetup'\nimport FormatError from './formatError'\n\nimport { formatISO } from 'date-fns'\nimport faker from 'faker'\n\nexport default class {\n  constructor (databaseSetup, { collectionsList = [], seedQuantity = 25 } = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.collectionsList = collectionsList\n    this.seedQuantity = seedQuantity\n    this.uuid = new Uuid()\n\n    this.seederTypes = {\n      boolean: '{{datatype.boolean}}',\n      checkbox: '{{lorem.word}}',\n      color: '{{internet.color}}',\n      date: '{{date.recent}}',\n      datetime: '{{datatype.datetime}}',\n      decimal: '{{random.float}}',\n      editor: '{{lorem.paragraphs}}',\n      email: '{{internet.email}}',\n      money: '{{commerce.price}}',\n      number: '{{datatype.number}}',\n      password: '{{internet.password}}',\n      percent: '{{random.float}}',\n      radio: '{{lorem.word}}',\n      select: '{{lorem.sentence}}',\n      text: '{{lorem.sentence}}',\n      string: '{{lorem.sentence}}',\n      textarea: '{{lorem.sentences}}',\n      time: '{{time.recent}}',\n      upload: '{{image.image}}'\n    }\n\n    this.defaultSchemaTypes = {\n      string: '__change__this__value__',\n      array: ['__change__this__value__']\n    }\n  }\n\n  initialize () {\n    return this.handleCollections()\n  }\n\n  async handleCollections () {\n    for (const collectionName of this.collectionsList) {\n      try {\n        const collection = this.databaseSetup.collections[collectionName]\n        const collectionHandler = new CollectionHandler(collection)\n        const fields = collectionHandler.getAllFields()\n        await this.generateDocuments(fields, collection)\n      } catch {\n        throw new FormatError({\n          errors: {\n            collection: collectionName\n          },\n          status: {\n            code: 500,\n            text: `Error on generate seed of collection ${collectionName}`\n          }\n        })\n      }\n    }\n\n    return Promise.resolve(true)\n  }\n\n  _propsHandler (props) {\n    function _getField () {\n      return props && props.field\n    }\n\n    return {\n      getField () {\n        return _getField()\n      },\n\n      getSeedValue () {\n        return props && props.seedValue\n      },\n\n      getType () {\n        return _getField() && _getField().type\n      }\n    }\n  }\n\n  generateDocuments (fields = {}, collection) {\n    const documents = []\n    const normalizedField = {}\n\n    for (const key in fields) {\n      const field = fields[key]\n      const { props, type, ref } = field\n      const { getField, getSeedValue, getType } = this._propsHandler(props)\n\n      if (key.startsWith('_')) continue\n\n      if (ref || (props && props.manyToMany)) {\n        normalizedField[key] = this.defaultSchemaTypes[type || getType()]\n        continue\n      }\n\n      normalizedField[key] = this.normalizeValue(\n        (getSeedValue() || getType() || type),\n        key,\n        field\n      )\n    }\n\n    for (let index = 1; index <= this.seedQuantity; index++) {\n      documents.push({ ...normalizedField, uuid: this.uuid.create() })\n    }\n\n    return this.populate(documents, collection)\n  }\n\n  normalizeValue (type, key, field) {\n    const dateNow = formatISO(new Date())\n\n    const models = {\n      select: () => {\n        const value = faker.fake(this.seederTypes[type])\n\n        return field.multiple ? value : [value]\n      },\n      datetime: () => dateNow,\n      number: () => Number(faker.fake(this.seederTypes[type])),\n      nested: () => [],\n      boolean: () => Boolean(faker.fake(this.seederTypes[type])),\n      createdAt: () => dateNow,\n      updatedAt: () => dateNow\n    }\n\n    const typeModel = models[type] && models[type]()\n    const keyModel = models[key] && models[key]()\n\n    try {\n      return typeModel || keyModel || faker.fake(this.seederTypes[type])\n    } catch {\n      return type || key\n    }\n  }\n\n  populate (documents, collection) {\n    return collection.bulkInsert(documents)\n  }\n}\n"],"names":["options","databaseOptions","databaseName","this","alias","name","collectionsOptions","collections","database","initialize","addPlugins","require","plugin","addRxPlugin","plugins","forEach","_this","addPlugin","createRxDatabase","Error","databases","getDatabase","destroy","addCollections","collection","query","find","exec","list","length","callback","customFields","fields","getAllFields","key","props","schema","jsonSchema","properties","filtersFields","getCustomFields","filters","filter","filtersKey","field","getFiltersFields","object","search","push","nestedFields","custom","type","allFields","ref","value","JSON","parse","some","item","parseValue","receivedFilters","filtersList","receivedSearch","searchList","fieldsList","parseHandler","ParseHandler","queryOperator","defaultValues","$all","$eq","parseBoolean","transformedQuery","filterField","queryOrigin","Object","assign","_setDefaultValueToQueryOperator","$regex","selector","errors","status","code","response","data","collectionHandler","CollectionHandler","fieldsWithRelation","getFieldsWithRelation","documents","Array","isArray","document","parsedDocument","toJSON","fieldProps","uuid","label","cloneDeep","getOnlyFields","populate","setOptions","externalFields","date","Date","uuidv4","comb","getTime","toString","substr","slice","replace","c","crypto","getRandomValues","Uint8Array","rxError","parameters","FormatError","setErrors","errorMessages","errorMessage","customErrors","getErrorMessagesFromCustomFields","split","nested","destroyKey","index","counter","hasNext","next","current","id","splice","handler","VuexOffline","databaseSetup","DatabaseSetup","idAttribute","collectionName","middlewares","fetchListQuery","fetchListSuccess","fetchListError","fetchFiltersSuccess","fetchFiltersError","fetchSingleSuccess","fetchSingleFormSuccess","fetchSingleError","saveSuccess","saveError","createSuccess","createError","perPage","window","cl","getFiltersAndSearch","relationsHandler","RelationsHandler","Nested","save","commit","payload","model","findOne","text","updatedAt","formatISO","getNestedFields","nestedField","update","$set","result","saveSuccessResult","hasError","ValidateCustomError","module","namespaced","state","totalPages","onCreate","onFetchSingle","onFetchList","onReplace","onFetchFilters","getters","byId","mutations","setFilters","setList","results","increment","count","Math","ceil","setItemList","replaceItem","findIndex","removeItem","actions","create","Uuid","documentToBeInserted","dateNow","createdAt","insert","metadata","createSuccessResult","fetchSingle","form","params","url","getFieldsWithRelationOptions","fieldsWithRelationOptions","fetchSingleFormSuccessResult","getFieldsWithRelationOptionsById","fetchSingleSuccessResult","fetchFilters","filtersHandler","FiltersHandler","filterFields","getFilterFields","formattedFilterFields","fetchFilterSuccess","fetchFilterSuccessResult","fetchList","ordering","page","limit","transformQuery","skip","getCount","parsedDocuments","map","fetchListSuccessResult","remove","collectionsList","seedQuantity","seederTypes","checkbox","color","datetime","decimal","editor","email","money","number","password","percent","radio","select","string","textarea","time","upload","defaultSchemaTypes","array","handleCollections","generateDocuments","Promise","resolve","_getField","getField","getSeedValue","seedValue","getType","normalizedField","_propsHandler","startsWith","manyToMany","normalizeValue","models","faker","fake","multiple","Number","Boolean","typeModel","keyModel","bulkInsert"],"mappings":"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"}