{"version":3,"file":"index.min.js","sources":["../src/databaseSetup.js","../src/utils/collectionHandler.js","../src/utils/parseHandler.js","../src/utils/filtersHandler.js","../src/utils/formatError.js","../src/utils/relationsHandler.js","../src/utils/uuid.js","../src/utils/validateCustomError.js","../src/utils/nested.js","../src/vuexOffline.js","../src/utils/seeder.js"],"sourcesContent":["import { createRxDatabase, addRxPlugin } from 'rxdb'\n\n/**\n * Class to abstract the PouchDB implementation.\n *\n  * @param {options} DatabaseSetup options.\n */\nexport default class {\n  constructor (options = { databaseOptions: {} }) {\n    this.options = options\n    this.databaseOptions = options.databaseOptions\n    this.databaseName = this.databaseOptions.alias || this.databaseOptions.name\n    this.collectionsOptions = options.collections\n\n    this.database = null\n    this.collections = null\n\n    this.initialize()\n  }\n\n  initialize () {\n    this.addPlugins([\n      require('pouchdb-adapter-idb'),\n      require('pouchdb-adapter-http')\n    ])\n  }\n\n  /**\n   * Add a plugin to rxdb.\n   *\n   * @param {addRxPlugin} plugin PouchDB plugin\n   */\n  addPlugin (plugin) {\n    addRxPlugin(plugin)\n  }\n\n  /**\n   * Add a list of plugins to PouchDB.\n   *\n   * @param {PouchDB[]} plugins List of PouchDB plugins\n   */\n  addPlugins (plugins) {\n    return plugins.forEach(plugin => this.addPlugin(plugin))\n  }\n\n  async createDatabase () {\n    try {\n      this.database = await createRxDatabase(this.databaseOptions)\n\n      return this.database\n    } catch (error) {\n      throw new Error('Error creating database.', error)\n    }\n  }\n\n  /**\n   * Get the database\n   *\n   * @param {string} name name of db.\n   *\n   * @example\n   * databaseSetup.getDatabase('myDatabase')\n   */\n  getDatabase (name) {\n    return this.databases[name]\n  }\n\n  /**\n   * Get the databases list\n   */\n  getDatabaseList () {\n    return this.databases\n  }\n\n  /**\n   * Delete the database. Note that this has no impact on other replicated databases.\n   * Check: {@link https://rxdb.info/rx-database.html#destroy}\n   *\n   * @param {string} name name of database to be deleted\n   *\n   * @example\n   * databaseSetup.deleteDatabase('myDatabase')\n   */\n  async deleteDatabase (name) {\n    const database = this.getDatabase(name)\n\n    if (!database) {\n      throw new Error('Please provide a valid database to be deleted.')\n    }\n\n    try {\n      await database.destroy()\n    } catch (error) {\n      throw new Error('Error deleting database.', error)\n    }\n  }\n\n  async createCollections (collections) {\n    try {\n      // addCollections from rxdb\n      const collection = await this.database.addCollections(collections || this.collectionsOptions)\n\n      this.collections = this.database.collections\n\n      return collection\n    } catch (error) {\n      throw new Error('Error creating collections.', error)\n    }\n  }\n}\n","export default class {\n  constructor (collection) {\n    this.collection = collection\n  }\n\n  async getCount (query) {\n    const list = await this.collection.find(query).exec()\n\n    return list.length\n  }\n\n  getCustomFields (callback = function () {}) {\n    const customFields = {}\n    const fields = this.getAllFields()\n\n    for (const key in fields) {\n      if (fields[key].props) {\n        customFields[key] = fields[key].props\n        callback(fields[key].props, key)\n      }\n    }\n\n    return customFields\n  }\n\n  getAllFields () {\n    return this.collection.schema.jsonSchema.properties\n  }\n\n  getFiltersFields () {\n    const filtersFields = {}\n    const customFields = this.getCustomFields()\n\n    for (const key in customFields) {\n      const filters = customFields[key].filter\n\n      if (!filters) continue\n\n      if (typeof filters === 'boolean') {\n        filtersFields[key] = customFields[key].field\n        continue\n      }\n\n      for (const filtersKey in filters) {\n        filtersFields[filtersKey] = filters[filtersKey]\n      }\n    }\n\n    return filtersFields\n  }\n\n  getOnlyFields () {\n    const customFields = this.getCustomFields()\n    const fields = {}\n\n    for (const key in customFields) {\n      if (customFields[key].field) {\n        fields[key] = customFields[key].field\n      }\n    }\n\n    return fields\n  }\n\n  getFiltersAndSearch () {\n    const customFields = this.getFiltersFields()\n    const object = {\n      filters: [],\n      search: []\n    }\n\n    for (const key in customFields) {\n      object.filters.push(key)\n      customFields[key].search && object.search.push(key)\n    }\n\n    return object\n  }\n\n  getNestedFields (callback = function () {}) {\n    const nestedFields = {}\n\n    this.getCustomFields(custom => {\n      const { field } = custom\n\n      if (field && field.type === 'nested') {\n        nestedFields[field.name] = custom\n        callback(custom)\n      }\n    })\n\n    return nestedFields\n  }\n\n  getFieldsWithRelation () {\n    const fields = {}\n    const allFields = this.getAllFields()\n\n    for (const key in allFields) {\n      if (allFields[key].ref || (allFields[key].props && allFields[key].props.manyToMany)) {\n        fields[key] = allFields[key]\n      }\n    }\n\n    return fields\n  }\n\n  getCustomManyToManyFields (callback = function () {}) {\n    const fields = {}\n\n    this.getCustomFields((custom, key) => {\n      if (custom.manyToMany) {\n        fields[key] = custom\n        callback(custom)\n      }\n    })\n\n    return fields\n  }\n}\n","export default class {\n  parseValue (value) {\n    try { return JSON.parse(value) } catch { return value }\n  }\n\n  parseBoolean (value) {\n    return ['true', 'false'].some(item => item === value) ? this.parseValue(value) : value\n  }\n}\n","import ParseHandler from './parseHandler'\n\nexport default class {\n  constructor({ receivedFilters, filtersList, receivedSearch = '', searchList, fieldsList }) {\n    this.fieldsList = fieldsList\n    this.filtersList = filtersList\n    this.receivedFilters = receivedFilters\n    this.receivedSearch = receivedSearch\n    this.searchList = searchList\n    this.parseHandler = new ParseHandler()\n  }\n\n  getFilterFields () {\n    const filters = {}\n\n    for (const filter of this.filtersList) {\n      if (!this.fieldsList[filter]) {\n        throw new Error(`Filter \"${filter}\" doesn't exists.`)\n      }\n\n      filters[filter] = this.fieldsList[filter]\n    }\n\n    return filters\n  }\n\n  _setDefaultValueToQueryOperator (queryOperator, value) {\n    const defaultValues = {\n      $all: [value],\n      $eq: this.parseHandler.parseBoolean(value)\n    }\n\n    if (!(queryOperator in defaultValues)) {\n      return value\n    }\n\n    return defaultValues[queryOperator]\n  }\n\n  transformQuery () {\n    const transformedQuery = {}\n\n    for (const item of this.filtersList) {\n      const filterField = this.fieldsList[item]\n      transformedQuery[filterField.queryOrigin || item] = transformedQuery[filterField.queryOrigin || item] || {}\n\n      if (this.receivedFilters[item]) {\n        Object.assign(\n          transformedQuery[filterField.queryOrigin || item],\n          filterField.queryOperator\n            ? {\n              [filterField.queryOperator]: this._setDefaultValueToQueryOperator(\n                filterField.queryOperator, this.receivedFilters[item]\n              )\n            }\n            : { $regex: `.*${this.receivedFilters[item]}.*` }\n          )\n\n        continue\n      }\n\n      if (this.receivedSearch && filterField.search) {\n        Object.assign(transformedQuery[filterField.queryOrigin || item], { $regex: `.*${this.receivedSearch}.` })\n      }\n    }\n\n    return {\n      selector: {\n        ...transformedQuery\n      }\n    }\n  }\n}\n","export default class {\n  constructor ({ errors, status = { code: 400 } } = {}) {\n    return {\n      response: {\n        data: {\n          errors,\n          status\n        }\n      }\n    }\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport { cloneDeep } from 'lodash'\n\nexport default class {\n  constructor (collection, collections) {\n    this.collectionHandler = new CollectionHandler(collection)\n    this.fieldsWithRelation = this.collectionHandler.getFieldsWithRelation()\n    this.collections = collections\n  }\n\n  setOptions (documents = [], key, relationValues = []) {\n    if (!documents.length) return []\n\n    documents = Array.isArray(documents) ? documents : [documents]\n    const options = []\n\n    documents.forEach(document => {\n      const parsedDocument = document.toJSON()\n      const fieldProps = this.fieldsWithRelation[key].props\n      const relation = relationValues.find(item => item.uuid === document.uuid)\n\n      options.push({\n        value: fieldProps['refValue'] || document.uuid,\n        label: document[fieldProps['refLabel']],\n        data: parsedDocument,\n        relation\n      })\n\n      return parsedDocument\n    })\n\n    return options\n  }\n\n  _propsHandler (props) {\n    return {\n      getManyToMany () {\n        return props && props.manyToMany\n      }\n    }\n  }\n\n  async getFieldsWithRelationOptionsById (document) {\n    const fields = cloneDeep(this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      const { getManyToMany } = this._propsHandler(this.fieldsWithRelation[key].props)\n\n      if (getManyToMany()) {\n        const results = await this.collections[key].findByIds(document[key].map(item => item.uuid))\n        fields[key].options = this.setOptions(Array.from(results.values()), key, document[key])\n        continue\n      }\n\n      fields[key].options = this.setOptions(await document.populate(key) || [], key)\n    }\n\n    return fields\n  }\n\n  async getFieldsWithRelationOptions (externalFields) {\n    const fields = cloneDeep(externalFields || this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      const { getManyToMany } = this._propsHandler(this.fieldsWithRelation[key].props)\n\n      fields[key].options = this.setOptions(\n        await this.collections[\n          this.fieldsWithRelation[key].ref || getManyToMany()\n        ].find().exec(), key\n      )\n    }\n\n    return fields\n  }\n}\n","export default class {\n  create (date) {\n    date = date || new Date()\n\n    const uuid = this.uuidv4()\n    let comb = ('00000000000' + date.getTime().toString(16)).substr(-12)\n    comb = comb.slice(0, 8) + '-' + comb.slice(8, 12)\n\n    return uuid.replace(uuid.slice(0, 13), comb)\n  }\n\n  uuidv4 () {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n  }\n}\n","import FormatError from './formatError'\nimport CollectionHandler from './collectionHandler'\n\nexport default class {\n  constructor(rxError, collection) {\n    this.errors = rxError.parameters.errors\n    this.schema = rxError.parameters.schema\n    this.collectionHandler = new CollectionHandler(collection)\n    this.customFields = this.collectionHandler.getCustomFields()\n\n    return new FormatError({\n      errors: this.setErrors()\n    })\n  }\n\n  getErrorMessagesFromCustomFields () {\n    const errorMessages = {}\n\n    for (const key in this.customFields) {\n      if (this.customFields[key].errorMessage) {\n        errorMessages[key] = this.customFields[key].errorMessage\n      }\n    }\n\n    return errorMessages\n  }\n\n  setErrors () {\n    const errors = {}\n    const customErrors = this.getErrorMessagesFromCustomFields()\n\n    for (const error of this.errors) {\n      const { field } = error\n      const key = field.split('.')[1]\n\n      errors[key] = customErrors[key]\n    }\n\n    return errors\n  }\n}\n","export default class {\n  handler (nested = [], destroyKey = 'destroyed') {\n    if (!Array.isArray(nested)) {\n      throw new Error('Array needed.')\n    }\n\n    let index = 0\n    let counter = 1\n\n    function hasNext () {\n      return index < nested.length\n    }\n\n    function next () {\n      return nested[index++]\n    }\n\n    while (hasNext()) {\n      const current = next()\n\n      if (current.id && !current[destroyKey]) {\n        counter = current.id\n      }\n\n      if (current[destroyKey]) {\n        index--\n        nested.splice(index, 1)\n        continue\n      }\n\n      current.id = counter\n\n      for (const key in current) {\n        if (Array.isArray(current[key]) && current[key].length) {\n          this.handler(nested[index - 1][key])\n        }\n      }\n\n      counter++\n    }\n\n    return nested\n  }\n}\n","import { formatISO } from 'date-fns'\n\nimport DatabaseSetup from './databaseSetup'\nimport CollectionHandler from './utils/collectionHandler'\nimport FiltersHandler from './utils/filtersHandler'\nimport FormatError from './utils/formatError'\nimport RelationsHandler from './utils/relationsHandler'\nimport Uuid from './utils/uuid'\nimport ValidateCustomError from './utils/validateCustomError'\nimport Nested from './utils/nested'\n\nexport default class VuexOffline {\n  constructor (databaseSetup, options = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.idAttribute = options.idAttribute\n  }\n\n  async createStoreModule (collectionName, options = {}) {\n    if (!collectionName) {\n      throw new Error('CollectionName name must be sended.')\n    }\n\n    // middlewares\n    const {\n      // list\n      fetchListQuery,\n      fetchListSuccess,\n      fetchListError,\n\n      // filter\n      fetchFiltersSuccess,\n      fetchFiltersError,\n\n      // single\n      fetchSingleSuccess,\n      fetchSingleFormSuccess,\n      fetchSingleError,\n\n      // save\n      saveSuccess,\n      saveError,\n\n      // create\n      createSuccess,\n      createError\n    } = options.middlewares || {}\n\n    const idAttribute = options.idAttribute || this.idAttribute || 'uuid'\n    const perPage = options.perPage || 12\n    const collection = this.databaseSetup.collections[collectionName]\n\n    const collectionHandler = new CollectionHandler(collection)\n    const { filters: filtersList, search: searchList } = collectionHandler.getFiltersAndSearch()\n    const fieldsList = collectionHandler.getFiltersFields()\n    const allFields = collectionHandler.getAllFields()\n\n    const relationsHandler = new RelationsHandler(collection, this.databaseSetup.collections)\n\n    const nested = new Nested()\n\n    const save = async ({ commit }, { payload, id, model } = {}) => {\n      try {\n        const document = collection.findOne(id || payload.uuid)\n\n        if (!document || (!id && !payload.uuid)) {\n          throw new FormatError({\n            status: { code: '404', text: 'Not found' }\n          })\n        }\n\n        if (allFields.updatedAt) {\n          payload.updatedAt = formatISO(new Date())\n        }\n\n        collectionHandler.getNestedFields(nestedField => {\n          payload[nestedField.field.name] = nested.handler(\n            payload[nestedField.field.name]\n          )\n        })\n\n        const parsedDocument = await document.update({ $set: { ...payload } })\n        const response = {\n          data: {\n            result: parsedDocument,\n            status: { code: 200 }\n          }\n        }\n\n        const saveSuccessResult = (await saveSuccess && saveSuccess(response)) || {}\n\n        commit('setErrors', { model })\n        commit('replaceItem', saveSuccessResult.result || parsedDocument.toJSON())\n\n        return saveSuccess && saveSuccessResult || response\n      } catch (error) {\n        commit('setErrors', { model, hasError: true })\n        throw saveError && saveError(error) || new ValidateCustomError(error, collection)\n      }\n    }\n\n    const module = {\n      namespaced: true,\n\n      // states\n      state: {\n        filters: {},\n        list: [],\n        totalPages: 0,\n        errors: {\n          onCreate: false,\n          onFetchSingle: false,\n          onFetchList: false,\n          onReplace: false,\n          onFetchFilters: false\n        }\n      },\n\n      // getters\n      getters: {\n        list: state => state.list,\n\n        filters: state => state.filters,\n\n        totalPages: state => state.totalPages,\n\n        byId: state => id => state.list.find(item => item[idAttribute] === id)\n      },\n\n      // mutations\n      mutations: {\n        setFilters (state, payload) {\n          state.filters = payload\n        },\n\n        setList (state, payload) {\n          const { results, increment, count } = payload\n          state.list = results || []\n\n          increment ? state.list.push(...results) : state.list = results || []\n\n          state.totalPages = Math.ceil(count / perPage)\n        },\n\n        setItemList (state, payload = {}) {\n          state.list.push(payload)\n        },\n\n        setErrors (state, { model, hasError }) {\n          state[model] = !!hasError\n        },\n\n        replaceItem (state, payload) {\n          const index = state.list.findIndex(item => item[idAttribute] === payload[idAttribute])\n\n          ~index ? state.list.splice(index, 1, payload) : state.list.push(payload)\n        },\n\n        removeItem (state, id) {\n          const index = state.list.findIndex(item => item[idAttribute] === id)\n\n          ~index && state.list.splice(index, 1)\n        }\n      },\n\n      // actions\n      actions: {\n        create: async ({ commit }, { payload }) => {\n          try {\n            const uuid = new Uuid()\n            const documentToBeInserted = { uuid: uuid.create(), ...payload }\n            const dateNow = formatISO(new Date())\n\n            if (allFields.createdAt) {\n              documentToBeInserted.createdAt = dateNow\n            }\n\n            if (allFields.updatedAt) {\n              documentToBeInserted.updatedAt = dateNow\n            }\n\n            collectionHandler.getNestedFields(nestedField => {\n              documentToBeInserted[nestedField.field.name] = nested.handler(\n                documentToBeInserted[nestedField.field.name]\n              )\n            })\n\n            const document = await collection.insert(documentToBeInserted)\n            const parsedDocument = document.toJSON()\n\n            const response = {\n              data: {\n                metadata: { ...parsedDocument },\n                status: { code: 200 }\n              }\n            }\n\n            const createSuccessResult = (await createSuccess && createSuccess(response)) || {}\n\n            commit('setErrors', { model: 'onCreate' })\n            commit('setItemList', createSuccessResult.metadata || parsedDocument)\n\n            return createSuccess && createSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onCreate', hasError: true })\n            throw createError && createError(error) || new ValidateCustomError(error, collection)\n          }\n        },\n\n        replace: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onReplace' })\n        },\n\n        update: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onUpdate' })\n        },\n\n        fetchSingle: async ({ commit }, { form, id, params, url } = {}) => {\n          const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n\n          if (!id && form) {\n            const response = {\n              data: {\n                status: { code: 200 },\n                fields: fieldsWithRelationOptions\n              }\n            }\n\n            const fetchSingleFormSuccessResult = (await fetchSingleFormSuccess && fetchSingleFormSuccess(response))\n            return fetchSingleFormSuccessResult || response\n          }\n\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: '404', text: 'Not found' }\n              })\n            }\n\n            const parsedDocument = document.toJSON()\n            const fields = form\n              ? fieldsWithRelationOptions\n              : await relationsHandler.getFieldsWithRelationOptionsById(document)\n\n            const response = {\n              data: {\n                fields,\n                result: parsedDocument,\n                status: { code: 200 }\n              }\n            }\n\n            const fetchSingleSuccessResult = (await fetchSingleSuccess && fetchSingleSuccess({ ...response })) || {}\n\n            commit('replaceItem', fetchSingleSuccessResult.result || parsedDocument)\n            commit('setErrors', { model: 'onFetchSingle' })\n\n            return fetchSingleSuccess && fetchSingleSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchSingle', hasError: true })\n            throw fetchSingleError && fetchSingleError(error) || error\n          }\n        },\n\n        fetchFilters: async ({ commit }) => {\n          try {\n            const filtersHandler = new FiltersHandler({ filtersList, fieldsList })\n            const filterFields = filtersHandler.getFilterFields()\n            const formattedFilterFields = await relationsHandler.getFieldsWithRelationOptions(filterFields)\n\n            const response = {\n              fields: formattedFilterFields,\n              status: { code: 200 }\n            }\n\n            const fetchFilterSuccessResult = (await fetchFilterSuccess && fetchFilterSuccess(response)) || {}\n            commit('setFilters', fetchFilterSuccessResult.fields || formattedFilterFields)\n\n            return fetchFilterSuccess && fetchFilterSuccessResult || response\n          } catch (error) {\n            throw fetchSingleError && fetchSingleError(error) || error\n          }\n        },\n\n        fetchList: async ({ commit }, options = {}) => {\n          const { filters = {}, increment, ordering = [], page = 1, limit, search } = options\n          try {\n            const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n            const filtersHandler = new FiltersHandler({\n              receivedFilters: filters,\n              filtersList,\n              receivedSearch: search,\n              searchList,\n              fieldsList\n            })\n\n            const query = (\n              fetchListQuery && fetchListQuery({\n                fieldsWithRelationOptions, ...options\n              }) || filtersHandler.transformQuery()\n            )\n\n            const skip = (page - 1) * (limit || perPage)\n            const count = await collectionHandler.getCount(query)\n            const documents = await collection.find(query).limit(limit || perPage).skip(skip).exec()\n            const parsedDocuments = documents.map(document => document.toJSON())\n\n            const response = {\n              data: {\n                results: parsedDocuments,\n                fields: fieldsWithRelationOptions,\n                status: { code: 200 }\n              }\n            }\n\n            const fetchListSuccessResult = (await fetchListSuccess && fetchListSuccess(response)) || {}\n\n            commit('setList', { results: fetchListSuccessResult.results || parsedDocuments, increment, count })\n            commit('setErrors', { model: 'onFetchList' })\n\n            return fetchListSuccess && fetchListSuccessResult || response\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchList', hasError: true })\n            throw fetchListError && fetchListError(error) || error\n          }\n        },\n\n        destroy: async ({ commit }, { id } = {}) => {\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: 404, text: 'Not found' }\n              })\n            }\n\n            document.remove()\n\n            commit('removeItem', id)\n            commit('setErrors', { model: 'onDestroy' })\n\n            return { status: { code: 200 } }\n          } catch (error) {\n            commit('setErrors', { model: 'onDestroy', hasError: true })\n            throw error\n          }\n        }\n      }\n    }\n\n    Object.assign(module.actions, options.actions)\n    Object.assign(module.mutations, options.mutations)\n\n    return module\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport Uuid from './uuid'\nimport DatabaseSetup from '../databaseSetup'\nimport FormatError from './formatError'\n\nimport { formatISO } from 'date-fns'\nimport faker from 'faker'\n\nexport default class {\n  constructor (databaseSetup, { collectionsList = [], seedQuantity = 25 } = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.collectionsList = collectionsList\n    this.seedQuantity = seedQuantity\n    this.uuid = new Uuid()\n\n    this.seederTypes = {\n      boolean: '{{datatype.boolean}}',\n      checkbox: '{{lorem.word}}',\n      color: '{{internet.color}}',\n      date: '{{date.recent}}',\n      datetime: '{{datatype.datetime}}',\n      decimal: '{{random.float}}',\n      editor: '{{lorem.paragraphs}}',\n      email: '{{internet.email}}',\n      money: '{{commerce.price}}',\n      number: '{{datatype.number}}',\n      password: '{{internet.password}}',\n      percent: '{{random.float}}',\n      radio: '{{lorem.word}}',\n      select: '{{lorem.sentence}}',\n      text: '{{lorem.sentence}}',\n      string: '{{lorem.sentence}}',\n      textarea: '{{lorem.sentences}}',\n      time: '{{time.recent}}',\n      upload: '{{image.image}}'\n    }\n\n    this.defaultSchemaTypes = {\n      string: '__change__this__value__',\n      array: ['__change__this__value__']\n    }\n  }\n\n  initialize () {\n    return this.handleCollections()\n  }\n\n  async handleCollections () {\n    for (const collectionName of this.collectionsList) {\n      try {\n        const collection = this.databaseSetup.collections[collectionName]\n        const collectionHandler = new CollectionHandler(collection)\n        const fields = collectionHandler.getAllFields()\n        await this.generateDocuments(fields, collection)\n      } catch {\n        throw new FormatError({\n          errors: {\n            collection: collectionName\n          },\n          status: {\n            code: 500,\n            text: `Error on generate seed of collection ${collectionName}`\n          }\n        })\n      }\n    }\n\n    return Promise.resolve(true)\n  }\n\n  _propsHandler (props) {\n    function _getField () {\n      return props && props.field\n    }\n\n    return {\n      getField () {\n        return _getField()\n      },\n\n      getSeedValue () {\n        return props && props.seedValue\n      },\n\n      getType () {\n        return _getField() && _getField().type\n      }\n    }\n  }\n\n  generateDocuments (fields = {}, collection) {\n    const documents = []\n    const normalizedField = {}\n\n    for (const key in fields) {\n      const field = fields[key]\n      const { props, type, ref } = field\n      const { getField, getSeedValue, getType } = this._propsHandler(props)\n\n      if (key.startsWith('_')) continue\n\n      if (ref || (props && props.manyToMany)) {\n        normalizedField[key] = this.defaultSchemaTypes[type || getType()]\n        continue\n      }\n\n      normalizedField[key] = this.normalizeValue(\n        (getSeedValue() || getType() || type),\n        key,\n        field\n      )\n    }\n\n    for (let index = 1; index <= this.seedQuantity; index++) {\n      documents.push({ ...normalizedField, uuid: this.uuid.create() })\n    }\n\n    return this.populate(documents, collection)\n  }\n\n  normalizeValue (type, key, field) {\n    const dateNow = formatISO(new Date())\n\n    const models = {\n      select: () => {\n        const value = faker.fake(this.seederTypes[type])\n\n        return field.multiple ? value : [value]\n      },\n      datetime: () => dateNow,\n      number: () => Number(faker.fake(this.seederTypes[type])),\n      nested: () => [],\n      boolean: () => Boolean(faker.fake(this.seederTypes[type])),\n      createdAt: () => dateNow,\n      updatedAt: () => dateNow\n    }\n\n    const typeModel = models[type] && models[type]()\n    const keyModel = models[key] && models[key]()\n\n    try {\n      return typeModel || keyModel || faker.fake(this.seederTypes[type])\n    } catch {\n      return type || key\n    }\n  }\n\n  populate (documents, collection) {\n    return collection.bulkInsert(documents)\n  }\n}\n"],"names":["options","databaseOptions","databaseName","this","alias","name","collectionsOptions","collections","database","initialize","addPlugins","require","plugin","addRxPlugin","plugins","forEach","_this","addPlugin","createRxDatabase","Error","databases","getDatabase","destroy","addCollections","collection","query","find","exec","list","length","callback","customFields","fields","getAllFields","key","props","schema","jsonSchema","properties","filtersFields","getCustomFields","filters","filter","filtersKey","field","getFiltersFields","object","search","push","nestedFields","custom","type","allFields","ref","manyToMany","value","JSON","parse","some","item","parseValue","receivedFilters","filtersList","receivedSearch","searchList","fieldsList","parseHandler","ParseHandler","queryOperator","defaultValues","$all","$eq","parseBoolean","transformedQuery","filterField","queryOrigin","Object","assign","_setDefaultValueToQueryOperator","$regex","selector","errors","status","code","response","data","collectionHandler","CollectionHandler","fieldsWithRelation","getFieldsWithRelation","documents","relationValues","Array","isArray","document","parsedDocument","toJSON","fieldProps","relation","uuid","label","getManyToMany","cloneDeep","getOnlyFields","_propsHandler","findByIds","map","results","setOptions","from","values","populate","externalFields","date","Date","uuidv4","comb","getTime","toString","substr","slice","replace","c","crypto","getRandomValues","Uint8Array","rxError","parameters","FormatError","setErrors","errorMessages","errorMessage","customErrors","getErrorMessagesFromCustomFields","split","nested","destroyKey","index","counter","hasNext","next","current","id","splice","handler","VuexOffline","databaseSetup","DatabaseSetup","idAttribute","collectionName","middlewares","fetchListQuery","fetchListSuccess","fetchListError","fetchFiltersSuccess","fetchFiltersError","fetchSingleSuccess","fetchSingleFormSuccess","fetchSingleError","saveSuccess","saveError","createSuccess","createError","perPage","getFiltersAndSearch","relationsHandler","RelationsHandler","Nested","save","commit","payload","model","findOne","text","updatedAt","formatISO","getNestedFields","nestedField","update","$set","result","saveSuccessResult","hasError","ValidateCustomError","module","namespaced","state","totalPages","onCreate","onFetchSingle","onFetchList","onReplace","onFetchFilters","getters","byId","mutations","setFilters","setList","increment","count","Math","ceil","setItemList","replaceItem","findIndex","removeItem","actions","create","Uuid","documentToBeInserted","dateNow","createdAt","insert","metadata","createSuccessResult","fetchSingle","form","params","url","getFieldsWithRelationOptions","fieldsWithRelationOptions","fetchSingleFormSuccessResult","getFieldsWithRelationOptionsById","fetchSingleSuccessResult","fetchFilters","filtersHandler","FiltersHandler","filterFields","getFilterFields","formattedFilterFields","fetchFilterSuccess","fetchFilterSuccessResult","fetchList","ordering","page","limit","transformQuery","skip","getCount","parsedDocuments","fetchListSuccessResult","remove","collectionsList","seedQuantity","seederTypes","checkbox","color","datetime","decimal","editor","email","money","number","password","percent","radio","select","string","textarea","time","upload","defaultSchemaTypes","array","handleCollections","generateDocuments","Promise","resolve","_getField","getField","getSeedValue","seedValue","getType","normalizedField","startsWith","normalizeValue","models","faker","fake","multiple","Number","Boolean","typeModel","keyModel","bulkInsert"],"mappings":"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"}