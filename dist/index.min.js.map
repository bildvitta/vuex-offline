{"version":3,"file":"index.min.js","sources":["../src/databaseSetup.js","../src/utils/collectionHandler.js","../src/utils/parseHandler.js","../src/utils/filtersHandler.js","../src/utils/formatError.js","../src/utils/relationsHandler.js","../src/utils/uuid.js","../src/utils/validateCustomError.js","../src/utils/nested.js","../src/vuexOffline.js","../src/utils/seeder.js"],"sourcesContent":["import { createRxDatabase, addRxPlugin } from 'rxdb'\n\n/**\n * Class to abstract the PouchDB implementation.\n *\n  * @param {options} DatabaseSetup options.\n */\nexport default class {\n  constructor (options = { databaseOptions: {} }) {\n    this.options = options\n    this.databaseOptions = options.databaseOptions\n    this.databaseName = this.databaseOptions.alias || this.databaseOptions.name\n    this.collectionsOptions = options.collections\n\n    this.database = null\n    this.collections = null\n\n    this.initialize()\n  }\n\n  initialize () {\n    this.addPlugins([\n      require('pouchdb-adapter-idb'),\n      require('pouchdb-adapter-http')\n    ])\n  }\n\n  /**\n   * Add a plugin to rxdb.\n   *\n   * @param {addRxPlugin} plugin PouchDB plugin\n   */\n  addPlugin (plugin) {\n    addRxPlugin(plugin)\n  }\n\n  /**\n   * Add a list of plugins to PouchDB.\n   *\n   * @param {PouchDB[]} plugins List of PouchDB plugins\n   */\n  addPlugins (plugins) {\n    return plugins.forEach(plugin => this.addPlugin(plugin))\n  }\n\n  async createDatabase () {\n    try {\n      this.database = await createRxDatabase(this.databaseOptions)\n\n      return this.database\n    } catch (error) {\n      throw new Error('Error creating database.', error)\n    }\n  }\n\n  /**\n   * Get the database\n   *\n   * @param {string} name name of db.\n   *\n   * @example\n   * databaseSetup.getDatabase('myDatabase')\n   */\n  getDatabase (name) {\n    return this.databases[name]\n  }\n\n  /**\n   * Get the databases list\n   */\n  getDatabaseList () {\n    return this.databases\n  }\n\n  /**\n   * Delete the database. Note that this has no impact on other replicated databases.\n   * Check: {@link https://rxdb.info/rx-database.html#destroy}\n   *\n   * @param {string} name name of database to be deleted\n   *\n   * @example\n   * databaseSetup.deleteDatabase('myDatabase')\n   */\n  async deleteDatabase (name) {\n    const database = this.getDatabase(name)\n\n    if (!database) {\n      throw new Error('Please provide a valid database to be deleted.')\n    }\n\n    try {\n      await database.destroy()\n    } catch (error) {\n      throw new Error('Error deleting database.', error)\n    }\n  }\n\n  async createCollections (collections) {\n    try {\n      // addCollections from rxdb\n      const collection = await this.database.addCollections(collections || this.collectionsOptions)\n      this.collections = this.database.collections\n\n      return collection\n    } catch (error) {\n      throw new Error('Error creating collections.', error)\n    }\n  }\n}\n","export default class {\n  constructor (collection) {\n    this.collection = collection\n  }\n\n  async getCount (query) {\n    const list = await this.collection.find(query).exec()\n\n    return list.length\n  }\n\n  getCustomFields (callback = function () {}) {\n    const customFields = {}\n    const fields = this.getAllFields()\n\n    for (const key in fields) {\n      if (fields[key].props) {\n        customFields[key] = fields[key].props\n        callback(fields[key].props)\n      }\n    }\n\n    return customFields\n  }\n\n  getAllFields () {\n    return this.collection.schema.jsonSchema.properties\n  }\n\n  getFiltersFields () {\n    const filtersFields = {}\n    const customFields = this.getCustomFields()\n\n    for (const key in customFields) {\n      const filters = customFields[key].filter\n\n      if (!filters) continue\n\n      if (typeof filters === 'boolean') {\n        filtersFields[key] = customFields[key].field\n        continue\n      }\n\n      for (const filtersKey in filters) {\n        filtersFields[filtersKey] = filters[filtersKey]\n      }\n    }\n\n    return filtersFields\n  }\n\n  getOnlyFields () {\n    const customFields = this.getCustomFields()\n    const fields = {}\n\n    for (const key in customFields) {\n      if (customFields[key].field) {\n        fields[key] = customFields[key].field\n      }\n    }\n\n    return fields\n  }\n\n  getFiltersAndSearch () {\n    const customFields = this.getFiltersFields()\n    const object = {\n      filters: [],\n      search: []\n    }\n\n    for (const key in customFields) {\n      object.filters.push(key)\n      customFields[key].search && object.search.push(key)\n    }\n\n    return object\n  }\n\n  getNestedFields (callback = function () {}) {\n    const nestedFields = {}\n\n    this.getCustomFields(custom => {\n      const { field } = custom\n\n      if (field && field.type === 'nested') {\n        nestedFields[field.name] = custom\n        callback(custom)\n      }\n    })\n\n    return nestedFields\n  }\n\n  getFieldsWithRelation () {\n    const fields = {}\n    const allFields = this.getAllFields()\n\n    for (const key in allFields) {\n      if (allFields[key].ref) {\n        fields[key] = allFields[key]\n      }\n    }\n\n    return fields\n  }\n}\n","export default class {\n  parseValue (value) {\n    try { return JSON.parse(value) } catch { return value }\n  }\n\n  parseBoolean (value) {\n    return ['true', 'false'].some(item => item === value) ? this.parseValue(value) : value\n  }\n}\n","import ParseHandler from './parseHandler'\n\nexport default class {\n  constructor({ receivedFilters, filtersList, receivedSearch = '', searchList, fieldsList }) {\n    this.fieldsList = fieldsList\n    this.filtersList = filtersList\n    this.receivedFilters = receivedFilters\n    this.receivedSearch = receivedSearch\n    this.searchList = searchList\n    this.parseHandler = new ParseHandler()\n  }\n\n  getFilterFields () {\n    const filters = {}\n\n    for (const filter of this.filtersList) {\n      if (!this.fieldsList[filter]) {\n        throw new Error(`Filter \"${filter}\" doesn't exists.`)\n      }\n\n      filters[filter] = this.fieldsList[filter]\n    }\n\n    return filters\n  }\n\n  _setDefaultValueToQueryOperator (queryOperator, value) {\n    const defaultValues = {\n      $all: [value],\n      $eq: this.parseHandler.parseBoolean(value)\n    }\n\n    if (!(queryOperator in defaultValues)) {\n      return value\n    }\n\n    return defaultValues[queryOperator]\n  }\n\n  transformQuery () {\n    const transformedQuery = {}\n\n    for (const item of this.filtersList) {\n      const filterField = this.fieldsList[item]\n      transformedQuery[filterField.queryOrigin || item] = transformedQuery[filterField.queryOrigin || item] || {}\n\n      if (this.receivedFilters[item]) {\n        Object.assign(\n          transformedQuery[filterField.queryOrigin || item],\n          filterField.queryOperator\n            ? {\n              [filterField.queryOperator]: this._setDefaultValueToQueryOperator(\n                filterField.queryOperator, this.receivedFilters[item]\n              )\n            }\n            : { $regex: `.*${this.receivedFilters[item]}.*` }\n          )\n\n        continue\n      }\n\n      if (this.receivedSearch && filterField.search) {\n        Object.assign(transformedQuery[filterField.queryOrigin || item], { $regex: `.*${this.receivedSearch}.` })\n      }\n    }\n\n    return {\n      selector: {\n        ...transformedQuery\n      }\n    }\n  }\n}\n","export default class {\n  constructor ({ errors, status = { code: 400 } } = {}) {\n    return {\n      response: {\n        data: {\n          errors,\n          status\n        }\n      }\n    }\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport { cloneDeep } from 'lodash'\n\nexport default class {\n  constructor (collection, collections) {\n    this.collectionHandler = new CollectionHandler(collection)\n    this.fieldsWithRelation = this.collectionHandler.getFieldsWithRelation()\n    this.collections = collections\n  }\n\n  setOptions (documents = [], key) {\n    documents = Array.isArray(documents) ? documents : [documents]\n\n    const options = []\n\n    documents.forEach(document => {\n      const parsedDocument = document.toJSON()\n      const fieldProps = this.fieldsWithRelation[key].props\n\n      options.push({\n        value: fieldProps['refValue'] || document.uuid,\n        label: document[fieldProps['refLabel']],\n        data: parsedDocument\n      })\n\n      return parsedDocument\n    })\n\n    return options\n  }\n\n  async getFieldsWithRelationOptionsById (document) {\n    const fields = cloneDeep(this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      fields[key].options = this.setOptions(\n        await document.populate(key) || [], key\n      )\n    }\n\n    return fields\n  }\n\n  async getFieldsWithRelationOptions (externalFields) {\n    const fields = cloneDeep(externalFields || this.collectionHandler.getOnlyFields())\n\n    for (const key in this.fieldsWithRelation) {\n      fields[key].options = this.setOptions(\n        await this.collections[this.fieldsWithRelation[key].ref].find().exec(), key\n      )\n    }\n\n    return fields\n  }\n}\n","export default class {\n  create (date) {\n    date = date || new Date()\n\n    const uuid = this.uuidv4()\n    let comb = ('00000000000' + date.getTime().toString(16)).substr(-12)\n    comb = comb.slice(0, 8) + '-' + comb.slice(8, 12)\n\n    return uuid.replace(uuid.slice(0, 13), comb)\n  }\n\n  uuidv4 () {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n  }\n}\n","import FormatError from './formatError'\nimport CollectionHandler from './collectionHandler'\n\nexport default class {\n  constructor(rxError, collection) {\n    this.errors = rxError.parameters.errors\n    this.schema = rxError.parameters.schema\n    this.collectionHandler = new CollectionHandler(collection)\n    this.customFields = this.collectionHandler.getCustomFields()\n\n    return new FormatError({\n      errors: this.setErrors()\n    })\n  }\n\n  getErrorMessagesFromCustomFields () {\n    const errorMessages = {}\n\n    for (const key in this.customFields) {\n      if (this.customFields[key].errorMessage) {\n        errorMessages[key] = this.customFields[key].errorMessage\n      }\n    }\n\n    return errorMessages\n  }\n\n  setErrors () {\n    const errors = {}\n    const customErrors = this.getErrorMessagesFromCustomFields()\n\n    for (const error of this.errors) {\n      const { field } = error\n      const key = field.split('.')[1]\n\n      errors[key] = customErrors[key]\n    }\n\n    return errors\n  }\n}\n","export default class {\n  handler (nested = [], destroyKey = 'destroyed') {\n    if (!Array.isArray(nested)) {\n      throw new Error('Array needed.')\n    }\n\n    let index = 0\n    let counter = 1\n\n    function hasNext () {\n      return index < nested.length\n    }\n\n    function next () {\n      return nested[index++]\n    }\n\n    while (hasNext()) {\n      const current = next()\n\n      if (current.id && !current[destroyKey]) {\n        counter = current.id\n      }\n\n      if (current[destroyKey]) {\n        index--\n        nested.splice(index, 1)\n        continue\n      }\n\n      current.id = counter\n\n      for (const key in current) {\n        if (Array.isArray(current[key]) && current[key].length) {\n          this.handler(nested[index - 1][key])\n        }\n      }\n\n      counter++\n    }\n\n    return nested\n  }\n}\n","import { formatISO } from 'date-fns'\n\nimport DatabaseSetup from './databaseSetup'\nimport CollectionHandler from './utils/collectionHandler'\nimport FiltersHandler from './utils/filtersHandler'\nimport FormatError from './utils/formatError'\nimport RelationsHandler from './utils/relationsHandler'\nimport Uuid from './utils/uuid'\nimport ValidateCustomError from './utils/validateCustomError'\nimport Nested from './utils/nested'\n\nexport default class VuexOffline {\n  constructor (databaseSetup, options = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.idAttribute = options.idAttribute\n  }\n\n  async createStoreModule (collectionName, options = {}) {\n    if (!collectionName) {\n      throw new Error('CollectionName name must be sended.')\n    }\n\n    const idAttribute = options.idAttribute || this.idAttribute || 'uuid'\n    const perPage = options.perPage || 12\n    const collection = this.databaseSetup.collections[collectionName]\n\n    const collectionHandler = new CollectionHandler(collection)\n    const { filters: filtersList, search: searchList } = collectionHandler.getFiltersAndSearch()\n    const fieldsList = collectionHandler.getFiltersFields()\n    const allFields = collectionHandler.getAllFields()\n\n    const relationsHandler = new RelationsHandler(collection, this.databaseSetup.collections)\n\n    const nested = new Nested()\n\n    const save = async ({ commit }, { payload, id, model } = {}) => {\n      try {\n        const document = collection.findOne(id || payload.uuid)\n\n        if (!document || (!id && !payload.uuid)) {\n          throw new FormatError({\n            status: { code: '404', text: 'Not found' }\n          })\n        }\n\n        if (allFields.updatedAt) {\n          payload.updatedAt = formatISO(new Date())\n        }\n\n        collectionHandler.getNestedFields(nestedField => {\n          payload[nestedField.field.name] = nested.handler(\n            payload[nestedField.field.name]\n          )\n        })\n\n        const parsedDocument = await document.update({ $set: { ...payload } })\n\n        commit('setErrors', { model })\n        commit('replaceItem', parsedDocument.toJSON())\n\n        return {\n          data: {\n            result: parsedDocument,\n            status: { code: 200 }\n          }\n        }\n      } catch (error) {\n        commit('setErrors', { model, hasError: true })\n        throw new ValidateCustomError(error, collection)\n      }\n    }\n\n    const module = {\n      namespaced: true,\n\n      // states\n      state: {\n        filters: {},\n        list: [],\n        totalPages: 0,\n        errors: {\n          onCreate: false,\n          onFetchSingle: false,\n          onFetchList: false,\n          onReplace: false,\n          onFetchFilters: false\n        }\n      },\n\n      // getters\n      getters: {\n        list: state => state.list,\n\n        filters: state => state.filters,\n\n        totalPages: state => state.totalPages,\n\n        byId: state => id => state.list.find(item => item[idAttribute] === id)\n      },\n\n      // mutations\n      mutations: {\n        setFilters (state, payload) {\n          state.filters = payload\n        },\n\n        setList (state, payload) {\n          const { results, increment, count } = payload\n          state.list = results || []\n\n          increment ? state.list.push(...results) : state.list = results || []\n\n          state.totalPages = Math.ceil(count / perPage)\n        },\n\n        setItemList (state, payload = {}) {\n          state.list.push(payload)\n        },\n\n        setErrors (state, { model, hasError }) {\n          state[model] = !!hasError\n        },\n\n        replaceItem (state, payload) {\n          const index = state.list.findIndex(item => item[idAttribute] === payload[idAttribute])\n\n          ~index ? state.list.splice(index, 1, payload) : state.list.push(payload)\n        },\n\n        removeItem (state, id) {\n          const index = state.list.findIndex(item => item[idAttribute] === id)\n\n          ~index && state.list.splice(index, 1)\n        }\n      },\n\n      // actions\n      actions: {\n        create: async ({ commit }, { payload }) => {\n          try {\n            const uuid = new Uuid()\n            const documentToBeInserted = { uuid: uuid.create(), ...payload }\n            const dateNow = formatISO(new Date())\n\n            if (allFields.createdAt) {\n              documentToBeInserted.createdAt = dateNow\n            }\n\n            if (allFields.updatedAt) {\n              documentToBeInserted.updatedAt = dateNow\n            }\n\n            collectionHandler.getNestedFields(nestedField => {\n              documentToBeInserted[nestedField.field.name] = nested.handler(\n                documentToBeInserted[nestedField.field.name]\n              )\n            })\n\n            const document = await collection.insert(documentToBeInserted)\n            const parsedDocument = document.toJSON()\n\n            commit('setErrors', { model: 'onCreate' })\n            commit('setItemList', parsedDocument)\n\n            return {\n              data: {\n                metadata: { ...parsedDocument },\n                status: { code: 200 }\n              }\n            }\n          } catch (error) {\n            commit('setErrors', { model: 'onCreate', hasError: true })\n            throw new ValidateCustomError(error, collection)\n          }\n        },\n\n        replace: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onReplace' })\n        },\n\n        update: async ({ commit }, { payload, id } = {}) => {\n          return save({ commit }, { payload, id, model: 'onUpdate' })\n        },\n\n        fetchSingle: async ({ commit }, { form, id, params, url } = {}) => {\n          const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n\n          if (!id && form) {\n            return {\n              data: {\n                status: { code: 200 },\n                fields: fieldsWithRelationOptions\n              }\n            }\n          }\n\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: '404', text: 'Not found' }\n              })\n            }\n\n            const parsedDocument = document.toJSON()\n            const fields = form\n              ? fieldsWithRelationOptions\n              : await relationsHandler.getFieldsWithRelationOptionsById(document)\n\n            commit('replaceItem', parsedDocument)\n            commit('setErrors', { model: 'onFetchSingle' })\n\n            return {\n              data: {\n                fields,\n                result: parsedDocument,\n                status: { code: 200 }\n              }\n            }\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchSingle', hasError: true })\n            throw error\n          }\n        },\n\n        fetchFilters: async ({ commit }) => {\n          const filtersHandler = new FiltersHandler({ filtersList, fieldsList })\n          const filterFields = filtersHandler.getFilterFields()\n          const formattedFilterFields = await relationsHandler.getFieldsWithRelationOptions(filterFields)\n\n          commit('setFilters', formattedFilterFields)\n\n          return {\n            fields: formattedFilterFields,\n            status: { code: 200 }\n          }\n        },\n\n        fetchList: async (\n          { commit },\n          { filters = {}, increment, ordering = [], page = 1, limit, search } = {}\n        ) => {\n          try {\n            const fieldsWithRelationOptions = await relationsHandler.getFieldsWithRelationOptions()\n            const filtersHandler = new FiltersHandler({\n              receivedFilters: filters,\n              filtersList,\n              receivedSearch: search,\n              searchList,\n              fieldsList\n            })\n\n            const skip = (page - 1) * (limit || perPage)\n            const query = filtersHandler.transformQuery()\n            const count = await collectionHandler.getCount(query)\n            const documents = await collection.find(query).limit(limit || perPage).skip(skip).exec()\n            const parsedDocuments = documents.map(document => document.toJSON())\n\n            commit('setList', { results: parsedDocuments, increment, count })\n            commit('setErrors', { model: 'onFetchList' })\n\n            return {\n              data: {\n                results: parsedDocuments,\n                fields: fieldsWithRelationOptions,\n                status: { code: 200 }\n              }\n            }\n          } catch (error) {\n            commit('setErrors', { model: 'onFetchList', hasError: true })\n            throw error\n          }\n        },\n\n        destroy: async ({ commit }, { id } = {}) => {\n          try {\n            const document = await collection.findOne(id).exec()\n\n            if (!document) {\n              throw new FormatError({\n                status: { code: 404, text: 'Not found' }\n              })\n            }\n\n            document.remove()\n\n            commit('removeItem', id)\n            commit('setErrors', { model: 'onDestroy' })\n\n            return { status: { code: 200 } }\n          } catch (error) {\n            commit('setErrors', { model: 'onDestroy', hasError: true })\n            throw error\n          }\n        }\n      }\n    }\n\n    Object.assign(module.actions, options.actions)\n    Object.assign(module.mutations, options.mutations)\n\n    return module\n  }\n}\n","import CollectionHandler from './collectionHandler'\nimport Uuid from './uuid'\nimport DatabaseSetup from '../databaseSetup'\nimport FormatError from './formatError'\n\nimport { formatISO } from 'date-fns'\nimport faker from 'faker'\n\nexport default class {\n  constructor (databaseSetup, { collectionsList = [], seedQuantity = 25 } = {}) {\n    if (!(databaseSetup instanceof DatabaseSetup)) {\n      throw new Error('Please, provide an instance of DatabaseSetup')\n    }\n\n    this.databaseSetup = databaseSetup\n    this.collectionsList = collectionsList\n    this.seedQuantity = seedQuantity\n    this.uuid = new Uuid()\n\n    this.seederTypes = {\n      boolean: '{{datatype.boolean}}',\n      checkbox: '{{lorem.word}}',\n      color: '{{internet.color}}',\n      date: '{{date.recent}}',\n      datetime: '{{datatype.datetime}}',\n      decimal: '{{random.float}}',\n      editor: '{{lorem.paragraphs}}',\n      email: '{{internet.email}}',\n      money: '{{commerce.price}}',\n      number: '{{datatype.number}}',\n      password: '{{internet.password}}',\n      percent: '{{random.float}}',\n      radio: '{{lorem.word}}',\n      select: '{{lorem.sentence}}',\n      text: '{{lorem.sentence}}',\n      string: '{{lorem.sentence}}',\n      textarea: '{{lorem.sentences}}',\n      time: '{{time.recent}}',\n      upload: '{{image.image}}'\n    }\n\n    this.defaultSchemaTypes = {\n      string: '__change__this__value__',\n      array: ['__change__this__value__']\n    }\n  }\n\n  initialize () {\n    return this.handleCollections()\n  }\n\n  async handleCollections () {\n    for (const collectionName of this.collectionsList) {\n      try {\n        const collection = this.databaseSetup.collections[collectionName]\n        const collectionHandler = new CollectionHandler(collection)\n        const fields = collectionHandler.getAllFields()\n        await this.generateDocuments(fields, collection)\n      } catch {\n        throw new FormatError({\n          errors: {\n            collection: collectionName\n          },\n          status: {\n            code: 500,\n            text: `Error on generate seed of collection ${collectionName}`\n          }\n        })\n      }\n    }\n\n    return Promise.resolve(true)\n  }\n\n  _propsHandler (props) {\n    function _getField () {\n      return props && props.field\n    }\n\n    return {\n      getField () {\n        return _getField()\n      },\n\n      getSeedValue () {\n        return props && props.seedValue\n      },\n\n      getType () {\n        return _getField() && _getField().type\n      }\n    }\n  }\n\n  generateDocuments (fields = {}, collection) {\n    const documents = []\n    const normalizedField = {}\n\n    for (const key in fields) {\n      const field = fields[key]\n      const { props, type, ref } = field\n      const { getField, getSeedValue, getType } = this._propsHandler(props)\n\n      if (key.startsWith('_')) continue\n\n      if (ref || (props && props.manyToMany)) {\n        normalizedField[key] = this.defaultSchemaTypes[type || getType()]\n        continue\n      }\n\n      normalizedField[key] = this.normalizeValue(\n        (getSeedValue() || getType() || type),\n        key,\n        field\n      )\n    }\n\n    for (let index = 1; index <= this.seedQuantity; index++) {\n      documents.push({ ...normalizedField, uuid: this.uuid.create() })\n    }\n\n    return this.populate(documents, collection)\n  }\n\n  normalizeValue (type, key, field) {\n    const dateNow = formatISO(new Date())\n\n    const models = {\n      select: () => {\n        const value = faker.fake(this.seederTypes[type])\n\n        return field.multiple ? value : [value]\n      },\n      datetime: () => dateNow,\n      number: () => Number(faker.fake(this.seederTypes[type])),\n      nested: () => [],\n      boolean: () => Boolean(faker.fake(this.seederTypes[type])),\n      createdAt: () => dateNow,\n      updatedAt: () => dateNow\n    }\n\n    const typeModel = models[type] && models[type]()\n    const keyModel = models[key] && models[key]()\n\n    try {\n      return typeModel || keyModel || faker.fake(this.seederTypes[type])\n    } catch {\n      return type || key\n    }\n  }\n\n  populate (documents, collection) {\n    return collection.bulkInsert(documents)\n  }\n}\n"],"names":["options","databaseOptions","databaseName","this","alias","name","collectionsOptions","collections","database","initialize","addPlugins","require","plugin","addRxPlugin","plugins","forEach","_this","addPlugin","createRxDatabase","Error","databases","getDatabase","destroy","addCollections","collection","query","find","exec","list","length","callback","customFields","fields","getAllFields","key","props","schema","jsonSchema","properties","filtersFields","getCustomFields","filters","filter","filtersKey","field","getFiltersFields","object","search","push","nestedFields","custom","type","allFields","ref","value","JSON","parse","some","item","parseValue","receivedFilters","filtersList","receivedSearch","searchList","fieldsList","parseHandler","ParseHandler","queryOperator","defaultValues","$all","$eq","parseBoolean","transformedQuery","filterField","queryOrigin","Object","assign","_setDefaultValueToQueryOperator","$regex","selector","errors","status","code","response","data","collectionHandler","CollectionHandler","fieldsWithRelation","getFieldsWithRelation","documents","Array","isArray","document","parsedDocument","toJSON","fieldProps","uuid","label","cloneDeep","getOnlyFields","populate","setOptions","externalFields","date","Date","uuidv4","comb","getTime","toString","substr","slice","replace","c","crypto","getRandomValues","Uint8Array","rxError","parameters","FormatError","setErrors","errorMessages","errorMessage","customErrors","getErrorMessagesFromCustomFields","split","nested","destroyKey","index","counter","hasNext","next","current","id","splice","handler","VuexOffline","databaseSetup","DatabaseSetup","idAttribute","collectionName","perPage","getFiltersAndSearch","relationsHandler","RelationsHandler","Nested","save","commit","payload","model","findOne","text","updatedAt","formatISO","getNestedFields","nestedField","update","$set","result","hasError","ValidateCustomError","module","namespaced","state","totalPages","onCreate","onFetchSingle","onFetchList","onReplace","onFetchFilters","getters","byId","mutations","setFilters","setList","results","increment","count","Math","ceil","setItemList","replaceItem","findIndex","removeItem","actions","create","Uuid","documentToBeInserted","dateNow","createdAt","insert","metadata","fetchSingle","form","params","url","getFieldsWithRelationOptions","fieldsWithRelationOptions","getFieldsWithRelationOptionsById","fetchFilters","filtersHandler","FiltersHandler","filterFields","getFilterFields","formattedFilterFields","fetchList","ordering","page","limit","skip","transformQuery","getCount","parsedDocuments","map","remove","collectionsList","seedQuantity","seederTypes","checkbox","color","datetime","decimal","editor","email","money","number","password","percent","radio","select","string","textarea","time","upload","defaultSchemaTypes","array","handleCollections","generateDocuments","Promise","resolve","_getField","getField","getSeedValue","seedValue","getType","normalizedField","_propsHandler","startsWith","manyToMany","normalizeValue","models","faker","fake","multiple","Number","Boolean","typeModel","keyModel","bulkInsert"],"mappings":"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"}